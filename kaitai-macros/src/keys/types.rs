use crate::{
    keys::{
        doc::{doc, DocSpec},
        enums::{enums, EnumsSpec},
        meta::{meta, MetaSpec},
        seq::{seq, Attributes},
    },
    util::{assert_pattern, get_attr, sc_to_ucc},
};

use anyhow::{Context, Result};
use proc_macro2::{Ident, Span, TokenStream};
use quote::{quote, ToTokens};
use yaml_rust::{yaml, Yaml};

/// Struct that contains all the necessary data to create a [`TypeSpec`].
#[derive(Clone, PartialEq, Eq, Hash, Debug)]
pub struct TypeData<'a> {
    /// The hash map containing the necessary data to generate the type.
    pub map: &'a yaml::Hash,
    /// The ident that should be used for the generated struct.
    pub ident: proc_macro2::Ident,
    /// The attributes that should be applied to the generated struct.
    pub attrs: Vec<syn::Attribute>,
    /// The desired visibility of the generated struct.
    pub visibility: syn::Visibility,
    /// The meta information that applies to the type. The field is always set to
    /// [`Some`](Option::Some) if the [`TypeData`] is describing a user-defined type (i.e. any
    /// type specified in the `TypesSpec` of the ksy file).
    pub inherited_meta: Option<MetaSpec>,
}

#[derive(Clone, PartialEq, Eq, Hash, Debug)]
pub struct TypesSpec(Vec<TypeSpec>);

impl ToTokens for TypesSpec {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        for ty in &self.0 {
            tokens.extend(quote! { #ty });
        }
    }
}

#[derive(Clone, PartialEq, Eq, Hash, Debug)]
pub struct TypeSpec {
    pub meta: MetaSpec,
    // pub params: Option<ParamSpec>
    pub seq: Attributes,
    pub types: TypesSpec,
    pub enums: EnumsSpec,
    // pub instances: InstancesSpec,
    pub doc: DocSpec,
    pub rust_info: RustTypeInfo,
}

#[derive(Clone, PartialEq, Eq, Hash, Debug)]
pub struct RustTypeInfo {
    pub attrs: Vec<syn::Attribute>,
    pub visibility: syn::Visibility,
    pub ident: proc_macro2::Ident,
}

impl ToTokens for TypeSpec {
    fn to_tokens(&self, tokens: &mut TokenStream) {
        let type_defs = &self.types;
        let enum_defs = &self.enums;
        let doc = &self.doc;
        let attrs = &self.rust_info.attrs;
        let visibility = &self.rust_info.visibility;
        let ident = &self.rust_info.ident;
        let field_definitions = self.seq.field_definitions();
        let field_assignments = self.seq.field_assignments(&self.meta);

        tokens.extend(quote! {
        #type_defs

        #enum_defs

        #doc
        #(#attrs)*
        #visibility struct #ident {
            #(#field_definitions,)*
        }

        // The `automatically_derived` attribute is applied to implementations generated by derive
        // macros. Since this `kaitai_source` isn't a derive macro, the `automatically_derived`
        // attributed must be applied manually.
        #[automatically_derived]
        impl ::kaitai::KaitaiStruct for #ident {
            fn new<S: ::kaitai::__private::KaitaiStream>(buf: &mut S) -> ::kaitai::error::Result<Self> {
                Ok(#ident {
                    #(#field_assignments,)*
                })
            }
            fn read<S: ::kaitai::__private::KaitaiStream>(&mut self, _: &mut S) -> ::kaitai::error::Result<()> {
                todo!();
            }
        }
        });
    }
}

pub fn types(data: &TypeData<'_>) -> Result<TypesSpec> {
    let map = data.map;

    let types = match get_attr!(map; "types" as Yaml::Hash(h) => h)
        .context("types: types is not a hashmap")?
    {
        Some(t) => t,
        None => return Ok(TypesSpec(Vec::new())),
    };

    let mut result = Vec::new();

    for (ident, map) in types {
        let ident = assert_pattern!(
            ident;
            Yaml::String(s) => Ident::new(&sc_to_ucc(s), Span::call_site());
            attr: "type ident")
        .context("types: type ident is not a string")?;
        let map = assert_pattern!(
            map;
            Yaml::Hash(h) => h;
            attr: "map")
        .context("types: type is not a hashmap")?;

        let child_info = TypeData {
            map,
            ident,
            attrs: Vec::new(),
            visibility: data.visibility.clone(),
            inherited_meta: data.inherited_meta,
        };

        result.push(ty(child_info).context("types: error generating child")?);
    }

    Ok(TypesSpec(result))
}

pub fn ty(data: TypeData<'_>) -> Result<TypeSpec> {
    let meta = meta(&data).context("ty: error parsing meta")?;
    let seq = seq(data.map).context("ty: error parsing seq")?;
    let types = types(&TypeData {
        map: data.map,
        inherited_meta: Some(meta),
        ..data.clone()
    })
    .context("ty: error parsing types")?;
    let enums = enums(data.map).context("ty: error parsing enums")?;
    let doc = doc(data.map).context("ty: error parsing doc/doc-ref")?;
    let rust_info = RustTypeInfo {
        attrs: data.attrs,
        visibility: data.visibility,
        ident: data.ident,
    };

    Ok(TypeSpec {
        meta,
        seq,
        types,
        enums,
        doc,
        rust_info,
    })
}
