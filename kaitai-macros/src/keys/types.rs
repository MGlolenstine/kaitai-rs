use crate::{
    keys::{
        doc::gen_doc_comment,
        seq::{gen_field_assignments, gen_field_defs},
    },
    utils::{get_attribute, MacroError},
    Result,
};

use proc_macro2::{Ident, Span};
use quote::{quote, ToTokens};
use yaml_rust::{yaml, Yaml};

pub fn get_types(map: &yaml::Hash) -> Result<Vec<(Ident, yaml::Hash)>> {
    let types = match get_attribute!(map | "types" as Yaml::Hash(h) => h) {
        Ok(t) => t,
        // types is not a required field in ksy.
        Err(MacroError::RequiredAttrNotFound(_)) => return Ok(Vec::new()),
        Err(e) => return Err(e),
    };
    let mut result = Vec::new();

    for (name, ty) in types {
        let ident = {
            let name = match name {
                Yaml::String(s) => s,
                _ => {
                    return Err(MacroError::InvalidAttrType {
                        attr: "type name".to_owned(),
                        pat: "Yaml::String(s)".to_owned(),
                        actual: name.clone(),
                    })
                }
            };
            Ident::new(name, Span::call_site())
        };
        match ty {
            Yaml::Hash(h) => result.push((ident, h.clone())),
            _ => {
                return Err(MacroError::InvalidAttrType {
                    attr: "type".to_owned(),
                    pat: "Yaml::Hash(h)".to_owned(),
                    actual: ty.clone(),
                })
            }
        }
    }

    Ok(result)
}

pub struct TypeOptions {
    pub ident: Option<proc_macro2::Ident>,
    pub attrs: Vec<syn::Attribute>,
    pub visibility: syn::Visibility,
}

/// Function that generates a Rust struct definition from a `yaml::Hash` in the format of a KSY
/// `TypeSpec`. The function is called recursively on all the types of the given `TypeSpec`. The
/// `struct`s generated by the function are public.
pub fn gen_type(map: &yaml::Hash, options: TypeOptions) -> Result<proc_macro2::TokenStream> {
    let _types = get_types(map)?;

    let doc_comment = gen_doc_comment(map)?;

    let attrs: Vec<proc_macro2::TokenStream> =
        options.attrs.iter().map(|a| a.to_token_stream()).collect();

    let visibility = options.visibility;

    let struct_ident = match options.ident {
        Some(i) => i,
        None => todo!(),
    };

    let field_defs = gen_field_defs(map)?;

    let field_assignments = gen_field_assignments(map)?;

    let result = quote! {
        #doc_comment
        #(#attrs)*
        #visibility struct #struct_ident {
            #(#field_defs,)*
        }

        // The `automatically_derived` attribute is applied to implementations generated by derive
        // macros. Since this `kaitai_source` isn't a derive macro, the `automatically_derived`
        // attributed must be applied manually.
        #[automatically_derived]
        impl ::kaitai::runtime::KaitaiStruct for #struct_ident {
            fn from<S: ::kaitai::runtime::KaitaiStream>(buf: &mut S) -> ::kaitai::Result<Self> {
                Ok(#struct_ident {
                    #(#field_assignments,)*
                })
            }
            fn read<S: ::kaitai::runtime::KaitaiStream>(&mut self, _: &mut S) -> ::kaitai::Result<()> {
                todo!();
            }
        }
    };
    Ok(result)
}
