use crate::{
    keys::{
        doc, meta,
        seq::{self, TypeDef},
    },
    utils::{get_attribute, sc_to_ucc, MacroError},
    Result,
};

use proc_macro2::{Ident, Span};
use quote::{quote, ToTokens};
use yaml_rust::{yaml, Yaml};

pub fn get_types(map: &yaml::Hash) -> Result<Vec<(Ident, yaml::Hash)>> {
    let types = match get_attribute!(map | "types" as Yaml::Hash(h) => h) {
        Ok(t) => t,
        // types is not a required field in ksy.
        Err(MacroError::RequiredAttrNotFound(_)) => return Ok(Vec::new()),
        Err(e) => return Err(e),
    };
    let mut result = Vec::new();

    for (name, ty) in types {
        let ident = {
            let name = match name {
                Yaml::String(s) => s,
                _ => {
                    return Err(MacroError::InvalidAttrType {
                        attr: "type name".to_owned(),
                        pat: "Yaml::String(s)".to_owned(),
                        actual: name.clone(),
                    })
                }
            };
            Ident::new(name, Span::call_site())
        };
        match ty {
            Yaml::Hash(h) => result.push((ident, h.clone())),
            _ => {
                return Err(MacroError::InvalidAttrType {
                    attr: "type".to_owned(),
                    pat: "Yaml::Hash(h)".to_owned(),
                    actual: ty.clone(),
                })
            }
        }
    }

    Ok(result)
}

pub struct TypeOptions {
    pub ident: Option<proc_macro2::Ident>,
    pub attrs: Vec<syn::Attribute>,
    pub visibility: syn::Visibility,
}

/// Function that generates a Rust struct definition from a `yaml::Hash` in the format of a KSY
/// `TypeSpec`. The function is called recursively on all the types of the given `TypeSpec`. The
/// `struct`s generated by the function are public.
pub fn create_type(map: &yaml::Hash, options: TypeOptions) -> Result<proc_macro2::TokenStream> {
    let meta = meta::get_meta(map)?;
    let seq = seq::get_seq(map)?;
    let doc = doc::get_doc(map)?;
    let _types = get_types(map)?;

    let fields: Vec<proc_macro2::TokenStream> = seq
        .iter()
        .map(|field| {
            let id = &field.id;
            quote! { #id }
        })
        .collect();
    let types: Vec<proc_macro2::TokenStream> = seq
        .iter()
        .map(|field| {
            let ty = field.rust_type();
            quote! { #ty }
        })
        .collect();
    let read_function_calls: Vec<proc_macro2::TokenStream> = seq
        .iter()
        .map(|field| {
            let mut func_name = String::new();

            match field.rust_type() {
                TypeDef::Inbuilt(_) => {
                    func_name.push_str("buf.read_");
                    func_name.push_str(&field.ks_type);
                    func_name.push_str(&meta.endianness.to_string());
                    func_name.push_str("()?");
                }
                TypeDef::Custom(_) => {
                    func_name.push_str(&sc_to_ucc(&field.ks_type));
                    func_name.push_str("::from(buf)?");
                }
            }

            // TODO get rid of unwrap
            func_name.parse().unwrap()
        })
        .collect();

    let doc_comment = (|| {
        if doc.description.is_none() && doc.reference.is_none() {
            return proc_macro2::TokenStream::new();
        }

        let description = match doc.description {
            Some(d) => d,
            None => "".to_owned(),
        };
        let reference = match doc.reference {
            Some(d) => {
                let mut result = String::new();
                result.push_str("\n### Reference\n");
                result.push_str(&d);
                result
            }
            None => "".to_owned(),
        };

        quote! {
            #[doc = concat!(#description, #reference)]
        }
    })();

    let visibility = options.visibility;

    let struct_ident = match options.ident {
        Some(i) => i,
        None => todo!(),
    };

    let attrs: Vec<proc_macro2::TokenStream> =
        options.attrs.iter().map(|a| a.to_token_stream()).collect();

    let result = quote! {
        #doc_comment
        #(#attrs)*
        #visibility struct #struct_ident {
            #(pub #fields: #types,)*
        }

        // The `automatically_derived` attribute is applied to implementations generated by derive
        // macros. Since this `kaitai_source` isn't a derive macro, the `automatically_derived`
        // attributed must be applied manually.
        #[automatically_derived]
        impl ::kaitai::runtime::KaitaiStruct for #struct_ident {
            fn from<S: ::kaitai::runtime::KaitaiStream>(buf: &mut S) -> ::kaitai::Result<Self> {
                Ok(#struct_ident {
                    #(#fields: #read_function_calls,)*
                })
            }
            fn read<S: ::kaitai::runtime::KaitaiStream>(&mut self, _: &mut S) -> ::kaitai::Result<()> {
                todo!();
            }
        }
    };
    Ok(result)
}
