use crate::{
    keys::{doc, meta, seq},
    utils::{get_attribute, MacroError},
    Result,
};

use quote::{quote, ToTokens};
use yaml_rust::{yaml, Yaml};

pub fn get_types(map: &yaml::Hash) -> Result<Vec<yaml::Hash>> {
    let types = match get_attribute!(map | "types" as Yaml::Array(a) => a) {
        Ok(t) => t,
        // types is not a required field in ksy.
        Err(MacroError::RequiredAttrNotFound(_)) => return Ok(Vec::new()),
        Err(e) => return Err(e),
    };
    let mut result = Vec::new();

    for ty in types {
        match ty {
            Yaml::Hash(h) => result.push(h.clone()),
            _ => {
                return Err(MacroError::InvalidAttrType {
                    attr: "type".to_owned(),
                    pat: "Yaml::Hash(h)".to_owned(),
                })
            }
        }
    }

    Ok(result)
}

pub struct TypeOptions {
    pub ident: Option<proc_macro2::Ident>,
    pub attrs: Vec<syn::Attribute>,
    pub visibility: syn::Visibility,
}

/// Function that generates a Rust struct definition from a `yaml::Hash` in the format of a KSY
/// `TypeSpec`. The function is called recursively on all the types of the given `TypeSpec`. The
/// `struct`s generated by the function are public.
pub fn create_type(map: &yaml::Hash, options: TypeOptions) -> Result<proc_macro2::TokenStream> {
    let meta = meta::get_meta(map)?;
    let seq = seq::get_seq(map)?;
    let doc = doc::get_doc(map)?;
    let _types = get_types(map)?;

    let fields: Vec<proc_macro2::TokenStream> = seq
        .iter()
        .map(|field| {
            let id = &field.id;
            quote! { #id }
        })
        .collect();
    let types: Vec<proc_macro2::TokenStream> = seq
        .iter()
        .map(|field| {
            let ty = field.rust_type();
            quote! { #ty }
        })
        .collect();
    let read_functions: Vec<proc_macro2::TokenStream> = seq
        .iter()
        .map(|field| {
            let mut func_name = String::new();

            func_name.push_str("read_");
            func_name.push_str(&field.ks_type);
            func_name.push_str(&meta.endianness.to_string());

            let func_ident = proc_macro2::Ident::new(&func_name, proc_macro2::Span::call_site());
            quote! { #func_ident }
        })
        .collect();

    let doc_comment = (|| {
        if doc.description.is_none() && doc.reference.is_none() {
            return proc_macro2::TokenStream::new();
        }

        let description = match doc.description {
            Some(d) => d,
            None => "".to_owned(),
        };
        let reference = match doc.reference {
            Some(d) => {
                let mut result = String::new();
                result.push_str("\n### Reference\n");
                result.push_str(&d);
                result
            }
            None => "".to_owned(),
        };

        quote! {
            #[doc = concat!(#description, #reference)]
        }
    })();

    let visibility = options.visibility;

    let struct_ident = match options.ident {
        Some(i) => i,
        None => todo!(),
    };

    let attrs: Vec<proc_macro2::TokenStream> =
        options.attrs.iter().map(|a| a.to_token_stream()).collect();

    let result = quote! {
        #doc_comment
        #(#attrs)*
        #visibility struct #struct_ident {
            #(pub #fields: #types,)*
        }

        // The `automatically_derived` attribute is applied to implementations generated by derive
        // macros. Since this `kaitai_source` isn't a derive macro, the `automatically_derived`
        // attributed must be applied manually.
        #[automatically_derived]
        impl ::kaitai::runtime::KaitaiStruct for #struct_ident {
            fn from<S: ::kaitai::runtime::KaitaiStream>(
                buf: &mut S,
                _: Option<&dyn::kaitai::runtime::KaitaiStruct>,
                _: Option<&dyn::kaitai::runtime::KaitaiStruct>, ) -> ::kaitai::Result<Self> {
                Ok(#struct_ident {
                    #(#fields: buf.#read_functions()?,)*
                })
            }
            fn read<S: ::kaitai::runtime::KaitaiStream>(
                &mut self,
                _: &mut S,
                _: Option<&dyn::kaitai::runtime::KaitaiStruct>,
                _: Option<&dyn::kaitai::runtime::KaitaiStruct>,
            ) -> ::kaitai::Result<()> {
                todo!();
            }
        }
    };
    Ok(result)
}
