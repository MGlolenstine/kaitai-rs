#![feature(proc_macro_span, register_tool)]
#![register_tool(tarpaulin)]

mod keys;
mod utils;

use keys::*;
use utils::{get_attribute, Result};

use std::path::Path;

use quote::{quote, ToTokens};
use syn::parse_macro_input;
use yaml_rust::{yaml, Yaml};

// Since it gets re-exported in kaitai, crate-level refers to kaitai not kaitai-macros.
/// See crate-level documentation for information on how to use this macro.
#[tarpaulin::skip]
#[proc_macro_attribute]
pub fn kaitai_source(
    args: proc_macro::TokenStream,
    item: proc_macro::TokenStream,
) -> proc_macro::TokenStream {
    let ks_source_path = parse_macro_input!(args as syn::LitStr);
    let item_ast = parse_macro_input!(item as syn::Item);

    let struct_item = match item_ast {
        syn::Item::Struct(s) => s,
        _ => {
            // TODO
            panic!("attribute not on struct");
        }
    };

    match &struct_item.fields {
        syn::Fields::Unit => {}
        _ => {
            // TODO
            panic!("struct has fields");
        }
    }

    // // Span::call_site() is a nightly feature.
    let mut source_file_path = proc_macro::Span::call_site().source_file().path();
    source_file_path.pop();
    let file_path = source_file_path.join(Path::new(&ks_source_path.value()));

    let file_contents = std::fs::read_to_string(file_path).expect("error reading file: ");
    let structure =
        &yaml_rust::YamlLoader::load_from_str(&file_contents).expect("error parsing file: ")[0];

    let result = match structure {
        Yaml::Hash(hm) => create_type(
            hm,
            TypeOptions {
                ident: Some(struct_item.ident),
                attrs: struct_item.attrs,
                visibility: struct_item.vis,
            },
        ),
        _ => panic!("file does not have the correct structure"),
    };
    result.unwrap().into()
}

struct TypeOptions {
    pub ident: Option<proc_macro2::Ident>,
    pub attrs: Vec<syn::Attribute>,
    pub visibility: syn::Visibility,
}

/// Function that generates a Rust `struct` definition from a Yaml hash map in the format of a KSY
/// `TypeSpec`. The function is called recursively on all the types of the given `TypeSpec`. The
/// `struct`s generated by the function are public.
fn create_type(map: &yaml::Hash, options: TypeOptions) -> Result<proc_macro2::TokenStream> {
    let meta = meta::get_meta(map)?;
    let seq = seq::get_seq(map)?;
    let doc = doc::get_doc(map)?;

    let fields: Vec<proc_macro2::TokenStream> = seq
        .iter()
        .map(|field| {
            let id = &field.id;
            quote! { #id }
        })
        .collect();
    let types: Vec<proc_macro2::TokenStream> = seq
        .iter()
        .map(|field| {
            let ty = field.rust_type();
            quote! { #ty }
        })
        .collect();
    let read_functions: Vec<proc_macro2::TokenStream> = seq
        .iter()
        .map(|field| {
            let mut func_name = String::new();

            func_name.push_str("read_");
            func_name.push_str(&field.ks_type);
            func_name.push_str(&meta.endianness.to_string());

            let func_ident = proc_macro2::Ident::new(&func_name, proc_macro2::Span::call_site());
            quote! { #func_ident }
        })
        .collect();

    let doc_comment = (|| {
        if doc.description.is_none() && doc.reference.is_none() {
            return proc_macro2::TokenStream::new();
        }

        let description = match doc.description {
            Some(d) => d,
            None => "".to_owned(),
        };
        let reference = match doc.reference {
            Some(d) => {
                let mut result = String::new();
                result.push_str("\n### Reference\n");
                result.push_str(&d);
                result
            }
            None => "".to_owned(),
        };

        quote! {
            #[doc = concat!(#description, #reference)]
        }
    })();

    let visibility = options.visibility;

    let struct_ident = match options.ident {
        Some(i) => i,
        None => todo!(),
    };

    let attrs: Vec<proc_macro2::TokenStream> =
        options.attrs.iter().map(|a| a.to_token_stream()).collect();

    let result = quote! {
        #doc_comment
        #(#attrs)*
        #visibility struct #struct_ident {
            #(pub #fields: #types,)*
        }

        // The `automatically_derived` attribute is applied to implementations generated by derive
        // macros. Since this `kaitai_source` isn't a derive macro, the `automatically_derived`
        // attributed must be applied manually.
        #[automatically_derived]
        impl ::kaitai::runtime::KaitaiStruct for #struct_ident {
            fn from<S: ::kaitai::runtime::KaitaiStream>(
                buf: &mut S,
                _: Option<&dyn::kaitai::runtime::KaitaiStruct>,
                _: Option<&dyn::kaitai::runtime::KaitaiStruct>, ) -> ::kaitai::Result<Self> {
                Ok(#struct_ident {
                    #(#fields: buf.#read_functions()?,)*
                })
            }
            fn read<S: ::kaitai::runtime::KaitaiStream>(
                &mut self,
                _: &mut S,
                _: Option<&dyn::kaitai::runtime::KaitaiStruct>,
                _: Option<&dyn::kaitai::runtime::KaitaiStruct>,
            ) -> ::kaitai::Result<()> {
                todo!();
            }
        }
    };
    Ok(result)
}
